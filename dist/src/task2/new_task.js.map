{"version":3,"sources":["../../../src/task2/new_task.js"],"names":["getRandomInt","min","max","Math","floor","random","getDots","str","i","connect","err","conn","createChannel","channel","queueName","msg","process","argv","assertQueue","durable","console","log","dots","sendToQueue","Buffer","persistent","setTimeout","close","exit"],"mappings":";;AAAA;;;;;;AAEA,IAAMA,eAAe,SAAfA,YAAe,CAACC,GAAD,EAAMC,GAAN,EAAc;AAC/B,WAAOC,KAAKC,KAAL,CAAWD,KAAKE,MAAL,MAAiBH,MAAMD,GAAN,GAAY,CAA7B,CAAX,IAA8CA,GAArD;AACH,CAFD;;AAIA,IAAMK,UAAU,SAAVA,OAAU,GAAM;AAClB,QAAIC,MAAM,GAAV;AACA,SAAI,IAAIC,IAAI,CAAZ,EAAeA,IAAGR,aAAa,CAAb,EAAgB,CAAhB,CAAlB,EAAsCQ,GAAtC,EAA2C;AACvCD,eAAO,GAAP;AACH;AACD,WAAOA,GAAP;AACH,CAND;;AAQA,uBAAKE,OAAL,CAAa,kBAAb,EAAiC,UAACC,GAAD,EAAMC,IAAN,EAAe;AAC5CA,SAAKC,aAAL,CAAmB,UAACF,GAAD,EAAMG,OAAN,EAAkB;AACjC,YAAMC,YAAY,YAAlB;AACA,YAAMC,MAAMC,QAAQC,IAAR,CAAa,CAAb,CAAZ;AACA;AACA;AACAJ,gBAAQK,WAAR,CAAoBJ,SAApB,EAA+B,EAACK,SAAS,IAAV,EAA/B;AACAC,gBAAQC,GAAR,CAAY,uDAAZ,EAAqEP,SAArE;AACA;AACA;AACA;AACA,aAAI,IAAIN,IAAE,CAAV,EAAaA,IAAE,EAAf,EAAmBA,GAAnB,EAAwB;AACpB,gBAAIc,OAAOhB,SAAX;AACAO,oBAAQU,WAAR,CAAoBT,SAApB,EAA+B,IAAIU,MAAJ,CAAWT,MAAMO,IAAjB,CAA/B,EAAuD,EAACG,YAAY,IAAb,EAAvD;AACAL,oBAAQC,GAAR,CAAY,gBAAZ,EAA8BN,MAAMO,IAApC;AACH;AACJ,KAfD;AAgBAI,eAAW,YAAW;AAAEf,aAAKgB,KAAL,GAAcX,QAAQY,IAAR,CAAa,CAAb;AAAiB,KAAvD,EAAyD,GAAzD;AACH,CAlBD","file":"new_task.js","sourcesContent":["import amqp from 'amqplib/callback_api';\n\nconst getRandomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nconst getDots = () => {\n    let str = '.';\n    for(let i = 1; i< getRandomInt(1, 6); i++) {\n        str += '.'\n    }\n    return str;\n}\n\namqp.connect('amqp://localhost', (err, conn) => {\n    conn.createChannel((err, channel) => {\n        const queueName = 'task_queue';\n        const msg = process.argv[2];\n        // When RabbitMQ quits or crashes it will forget the queues and messages unless you tell it not to.\n        // Two things are required to make sure that messages aren't lost: we need to mark both the queue and messages as durable.\n        channel.assertQueue(queueName, {durable: true});\n        console.log(\" [*] Waiting for messages in %s. To exit press CTRL+C\", queueName);\n        // Marking messages as persistent doesn't fully guarantee that a message won't be lost.\n        // Although it tells RabbitMQ to save the message to disk, there is still a short time window when\n        // RabbitMQ has accepted a message and hasn't saved it yet\n        for(let i=0; i<20; i++) {\n            let dots = getDots();\n            channel.sendToQueue(queueName, new Buffer(msg + dots), {persistent: true});\n            console.log(\" [x] Sent '%s'\", msg + dots);\n        }\n    });\n    setTimeout(function() { conn.close(); process.exit(0) }, 500);\n});\n"]}